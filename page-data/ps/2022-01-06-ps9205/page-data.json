{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/ps/2022-01-06-ps9205/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2>문제 링크</h2>\n<p><a href=\"https://www.acmicpc.net/problem/9205\" target=\"_blank\" rel=\"nofollow\">https://www.acmicpc.net/problem/9205</a>\n<br></p>\n<h2>문제 설명</h2>\n<img src = \"/assets/images/9205.png\">\n<br>  \n<h2>문제 입출력</h2>\n<img src = \"/assets/images/9205io.png\">\n<br>  \n<h2>풀이 방법</h2>\n<p>편의점 좌표가 오름차순 정렬된 채로 주어진 줄 알아서 첫 풀이는 입력대로 편의점 좌표를 갈 수 있는지 판단하는 로직이였다. 물론 틀렸고 모르겠어서 구글링을 통해 dfs 혹은 bfs로 푸는 방식인 것을 알았다. 집, 편의점, 락 페스티벌 좌표를 전부 그래프의 노드로 생각하며 탐색을 하는 풀이로 했어야했다. 처음에는 새로운 접근 방법이라 헷갈렸는데 혼자 끙끙하다보니 결국 풀었다.</p>\n<p>집, 편의점들, 락페는 노드이며 최대 총 102개이다. 인접 행렬(Adjacency-matrix)으로 간선정보를 저장한다. 단, 간선은 노드가 이동할 수 있는 경로일 때 저장되어야하므로 맨해튼 거리(각 좌표 차이의 합)로 1000미터보다 같거나 작은지 조건을 확인한다. 이후에는 0번 노드인 집 좌표에서 dfs를 수행한다. dfs가 모두 수행되면, 집에서 페스티벌까지 갈 수 있는지를 <code class=\"language-text\">visited[n+1]</code>으로 확인할 수 있다. dfs로 집에서 갈 수 있는 노드들(편의점들, 락페)을 <code class=\"language-text\">visited</code>에 저장했기 때문이다.\n<br></p>\n<h2>코드</h2>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define MAX_NUM 102\n\nint t;\nbool arr[MAX_NUM][MAX_NUM];\nbool visited[MAX_NUM];\nint n;\nint x, y;\n\nvoid dfs(int start, int end){\n    visited[start] = true;\n    for(int i=0; i&lt;n+2; i++){\n        if(arr[start][i] &amp;&amp; !visited[i]) dfs(i, end);\n    }\n}\n\nint main(){\n    cin &gt;&gt; t;\n    while(t--){\n        vector&lt;pair&lt;int, int&gt; &gt; v;\n        cin &gt;&gt; n;\n\n        for(int i=0; i&lt;n+2; i++){\n            cin &gt;&gt; x &gt;&gt; y;\n            v.push_back(make_pair(x, y));\n        }\n\n        for(int i=0; i&lt;MAX_NUM; i++){\n            for(int j=0; j&lt;MAX_NUM; j++){\n                arr[i][j] = false; \n            }\n            visited[i] = false;\n        }\n\n        for(int i=0; i&lt;v.size(); i++){\n            for(int j=0; j&lt;v.size(); j++){\n                if((abs(v[i].first - v[j].first) + abs(v[i].second - v[j].second)) &lt;= 1000) {\n                    arr[i][j] = true;\n                }\n            }\n        }\n\n        dfs(0, n+1);\n        if(visited[n+1]) cout &lt;&lt; &quot;happy&quot; &lt;&lt; &#39;\\n&#39;;\n        else cout &lt;&lt; &quot;sad&quot; &lt;&lt; &#39;\\n&#39;;\n    }\n}\n</code></pre></div>","frontmatter":{"title":"백준 9205번(맥주 마시면서 걸어가기) C++ 풀이","summary":"백준 9205번 맥주 마시면서 걸어가기 문제 풀이","date":null,"categories":["PS"],"thumbnail":null},"tableOfContents":"<ul>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C-%EB%A7%81%ED%81%AC\">문제 링크</a></li>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%84%A4%EB%AA%85\">문제 설명</a></li>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%9E%85%EC%B6%9C%EB%A0%A5\">문제 입출력</a></li>\n<li><a href=\"#%ED%92%80%EC%9D%B4-%EB%B0%A9%EB%B2%95\">풀이 방법</a></li>\n<li><a href=\"#%EC%BD%94%EB%93%9C\">코드</a></li>\n</ul>"}}]}},"pageContext":{"slug":"/ps/2022-01-06-ps9205/"}},
    "staticQueryHashes": ["3649515864"]}