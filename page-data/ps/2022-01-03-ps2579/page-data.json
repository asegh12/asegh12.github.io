{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/ps/2022-01-03-ps2579/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2>문제 링크</h2>\n<p><a href=\"https://www.acmicpc.net/problem/2579\" target=\"_blank\" rel=\"nofollow\">https://www.acmicpc.net/problem/2579</a>\n<br></p>\n<h2>문제 설명</h2>\n<img src=\"/assets/images/2579.png\">\n<br>  \n<h2>문제 입출력</h2>\n<img src=\"/assets/images/2579io.png\">\n<br>  \n<h2>풀이 방법</h2>\n<p>Dynamic Programming으로 접근하면 쉽게 할 수 있다.</p>\n<p>DP 배열을 생성한다. 0번 인덱스의 값은 0이다.</p>\n<p>DP 배열의 각 인덱스의 값을 생각해보자. 인덱스의 값은 해당 계단 번호를 밟았을 때 얻을 수 있는 최대 점수이다.</p>\n<p>dp[1] - 1번 인덱스는 1번 계단을 밟았을 때, 최대 점수이다. 따라서 1번 계단 점수가 된다.</p>\n<p>dp[2] - 2번 인덱스는 2번 계단을 밟았을 때, 최대 점수이다. 따라서 1번 계단과 2번 계단 점수의 합이다.</p>\n<p>dp[3] - 3번 인덱스부터는, 경우의 수를 따져보자.<br>\n<code class=\"language-text\">(1) : (1번 계단) + (3번 계단)</code><br>\n<code class=\"language-text\">(2) : (2번 계단) + (3번 계단) = (0번 계단) + (2번 계단) + (3번 계단)</code></p>\n<p>dp[4] - 4번 인덱스 경우의 수(여기서부터 자세히 보자)<br>\n<code class=\"language-text\">(1) : (1번 계단) + (2번 계단) + (4번 계단)</code><br>\n<code class=\"language-text\">(2) : (1번 계단) + (3번 계단) + (4번 계단)</code><br>\n<code class=\"language-text\">(3) : (2번 계단) + (4번 계단)</code></p>\n<p>4번 인덱스는 4번째 계단을 밟았을 때 최대의 점수이다. 따라서 4번 계단을 꼭 밟아야하고, 4번 계단을 밟으려면 위와 같은 경우의 수가 있다.</p>\n<p><code class=\"language-text\">(3)</code>번 경우의 수는 무시해도 된다. 4번 계단을 밟기 전, 2번 계단만 밟아서는 최대 점수가 될 수 없기 때문이다.<code class=\"language-text\">(dp[2] = 1번 계단 + 2번 계단)</code></p>\n<p><code class=\"language-text\">(1)</code>의 경우의 수는 1번, 2번 계단을 연속으로 밟고 4번 계단을 밟으므로 <code class=\"language-text\">dp[2] + 4번 계단 점수</code> 이다.</p>\n<p><code class=\"language-text\">(2)</code>의 경우는 1번 계단을 밟고 3, 4번을 연속으로 밟는다. <code class=\"language-text\">dp[1] + 3번 계단 점수 + 4번 계단 점수</code>인데, dp[3]이 되지 못한 이유는 dp[3]의 경우의 수 중 (2)로 최대 점수가 계산되었다면, 3연속 계단을 밟기 때문이다.</p>\n<p>따라서 dp의 인덱스 계산은 <code class=\"language-text\">dp[i] = max(dp[i-3] + stairs[i-1] + stairs[i], dp[i-2] + stairs[i])</code>가 된다.</p>\n<br>  \n<h2>코드</h2>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint n;\nint stairs[301];\nint dp[301];\n\nint main(){\n    cin &gt;&gt; n;\n    stairs[0] = 0;\n    for(int i=1; i&lt;=n; i++) cin &gt;&gt; stairs[i];\n    \n    dp[0] = stairs[0];\n    dp[1] = stairs[1];\n    dp[2] = stairs[1] + stairs[2];\n\n    for(int i=3; i&lt;=n; i++){\n        dp[i] = max(dp[i-3] + stairs[i-1] + stairs[i], dp[i-2] + stairs[i]);\n    }\n    \n    cout &lt;&lt; dp[n] &lt;&lt; endl;\n}</code></pre></div>","frontmatter":{"title":"백준 2579번(계단 오르기) C++ 풀이","summary":"백준 2579번 계단 오르기 문제 풀이","date":"2022.01.03.","categories":["PS"],"thumbnail":null},"tableOfContents":"<ul>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C-%EB%A7%81%ED%81%AC\">문제 링크</a></li>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%84%A4%EB%AA%85\">문제 설명</a></li>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%9E%85%EC%B6%9C%EB%A0%A5\">문제 입출력</a></li>\n<li><a href=\"#%ED%92%80%EC%9D%B4-%EB%B0%A9%EB%B2%95\">풀이 방법</a></li>\n<li><a href=\"#%EC%BD%94%EB%93%9C\">코드</a></li>\n</ul>"}}]}},"pageContext":{"slug":"/ps/2022-01-03-ps2579/"}},
    "staticQueryHashes": ["3649515864"]}