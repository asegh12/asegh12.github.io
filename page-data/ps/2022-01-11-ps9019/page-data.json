{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/ps/2022-01-11-ps9019/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2>문제 링크</h2>\n<p><a href=\"https://www.acmicpc.net/problem/9019\" target=\"_blank\" rel=\"nofollow\">https://www.acmicpc.net/problem/9019</a>\n<br></p>\n<h2>문제 설명</h2>\n<img src = \"/assets/images/9019.png\">\n<br>  \n<h2>문제 입출력</h2>\n<img src = \"/assets/images/9019io.png\">\n<br>  \n<h2>풀이 방법</h2>\n<p>BFS로 풀 수 있다. 나올 수 있는 수는 0부터 9999까지 한정되어 있으므로, 숫자를 노드라고 생각하면 된다. 엣지는 해당 노드(숫자)와 연산으로 표현될 수 있다. 예를 들어, 숫자는 <code class=\"language-text\">0001</code>, 연산은 <code class=\"language-text\">L</code>이라면 결과는 <code class=\"language-text\">0010</code>이다. 단, 여러 연산으로 표현될 수 있는데, <code class=\"language-text\">RRR</code> 연산으로도 <code class=\"language-text\">0001</code> -> <code class=\"language-text\">0010</code>이 된다. 시작 노드(A)부터 종료 노드(B)까지 각 노드에서 <code class=\"language-text\">D</code>, <code class=\"language-text\">S</code>, <code class=\"language-text\">L</code>, <code class=\"language-text\">R</code> 연산을 수행하여 탐색을 진행한다. 문제의 조건은 <code class=\"language-text\">최소한의 명령어</code>이므로 BFS을 수행하다가 가장 먼저 <code class=\"language-text\">B</code>와 같은 결과가 나온다면, 해당 연산을 출력하고 탐색을 중단하면 된다.\n<br></p>\n<h2>코드</h2>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint a, b;\nbool visited[10000];\n\nvoid bfs(){\n    queue&lt;pair&lt;int, string&gt; &gt; q;\n    q.push(make_pair(a, &quot;&quot;));\n    visited[a] = true;\n    int new_num;\n\n    while(!q.empty()){\n        int cur_num = q.front().first;\n        string cur_str = q.front().second;\n        q.pop();\n\n        if(cur_num == b){\n            cout &lt;&lt; cur_str &lt;&lt; &quot;\\n&quot;;\n            return;\n        }\n\n        new_num = (cur_num*2) % 10000;\n        if(!visited[new_num]){\n            visited[new_num] = true;\n            q.push(make_pair(new_num, cur_str + &#39;D&#39;));\n        }\n\n        new_num = cur_num-1;\n        if(new_num &lt; 0) new_num = 9999;\n        if(!visited[new_num]){\n            visited[new_num] = true;\n            q.push(make_pair(new_num, cur_str + &#39;S&#39;));\n        }\n\n        new_num = (cur_num%1000)*10 + (cur_num/1000);\n        if(!visited[new_num]){\n            visited[new_num] = true;\n            q.push(make_pair(new_num, cur_str + &#39;L&#39;));\n        }\n\n        new_num = cur_num/10 + (cur_num%10)*1000;\n        if(!visited[new_num]){\n            visited[new_num] = true;\n            q.push(make_pair(new_num, cur_str + &#39;R&#39;));\n        }\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int t;\n    cin &gt;&gt; t;\n    while(t--){\n        cin &gt;&gt; a &gt;&gt; b;\n        memset(visited, false, sizeof(visited));\n        bfs();\n    }\n    return 0;\n    \n}</code></pre></div>\n<h2>첨언</h2>\n<p>처음에는 그리디한 방식으로 무언가 최적화된 방법이 있을 줄 알았다. 하지만 이 문제는 출력이 여러 개일 수 있으므로 그리디하게 풀 수 없다. 또한 어떻게 구체적으로 어떤 접근을 해야할 지는 생각하지 않았지만 DP로도 풀 수 있겠다는 생각은 했다. 막상 하려니까 못했고… 결국 구글링을 해서 BFS로 접근해야 한다는 것을 알았다. BFS나 DFS는 탐색의 일종이라 그래프에서만 사용했었는데, 사고의 확장으로 이러한 문제에서도 적용시킬 수 있다는 것을 알았다. <b>유연한 사고<b>!!!</p>","frontmatter":{"title":"백준 9019번(DSLR) C++ 풀이","summary":"백준 9019번 DSLR 문제 풀이","date":null,"categories":["PS"],"thumbnail":null},"tableOfContents":"<ul>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C-%EB%A7%81%ED%81%AC\">문제 링크</a></li>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%84%A4%EB%AA%85\">문제 설명</a></li>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%9E%85%EC%B6%9C%EB%A0%A5\">문제 입출력</a></li>\n<li><a href=\"#%ED%92%80%EC%9D%B4-%EB%B0%A9%EB%B2%95\">풀이 방법</a></li>\n<li><a href=\"#%EC%BD%94%EB%93%9C\">코드</a></li>\n<li><a href=\"#%EC%B2%A8%EC%96%B8\">첨언</a></li>\n</ul>"}}]}},"pageContext":{"slug":"/ps/2022-01-11-ps9019/"}},
    "staticQueryHashes": ["3649515864"]}